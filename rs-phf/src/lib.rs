use rs_token::*;
use phf::phf_map;

static KEYWORDS: phf::Map<&'static [u8], TokenType> = phf_map! {
    b"abstract" => TokenType::kw_abstract,
    b"any" => TokenType::kw_any,
    b"as" => TokenType::kw_as,
    b"assert" => TokenType::kw_assert,
    b"asserts" => TokenType::kw_asserts,
    b"async" => TokenType::kw_async,
    b"await" => TokenType::kw_await,
    b"bigint" => TokenType::kw_bigint,
    b"boolean" => TokenType::kw_boolean,
    b"break" => TokenType::kw_break,
    b"case" => TokenType::kw_case,
    b"catch" => TokenType::kw_catch,
    b"class" => TokenType::kw_class,
    b"const" => TokenType::kw_const,
    b"constructor" => TokenType::kw_constructor,
    b"continue" => TokenType::kw_continue,
    b"debugger" => TokenType::kw_debugger,
    b"declare" => TokenType::kw_declare,
    b"default" => TokenType::kw_default,
    b"delete" => TokenType::kw_delete,
    b"do" => TokenType::kw_do,
    b"else" => TokenType::kw_else,
    b"enum" => TokenType::kw_enum,
    b"export" => TokenType::kw_export,
    b"extends" => TokenType::kw_extends,
    b"false" => TokenType::kw_false,
    b"finally" => TokenType::kw_finally,
    b"for" => TokenType::kw_for,
    b"from" => TokenType::kw_from,
    b"function" => TokenType::kw_function,
    b"get" => TokenType::kw_get,
    b"global" => TokenType::kw_global,
    b"if" => TokenType::kw_if,
    b"implements" => TokenType::kw_implements,
    b"import" => TokenType::kw_import,
    b"in" => TokenType::kw_in,
    b"infer" => TokenType::kw_infer,
    b"instanceof" => TokenType::kw_instanceof,
    b"interface" => TokenType::kw_interface,
    b"intrinsic" => TokenType::kw_intrinsic,
    b"is" => TokenType::kw_is,
    b"keyof" => TokenType::kw_keyof,
    b"let" => TokenType::kw_let,
    b"module" => TokenType::kw_module,
    b"namespace" => TokenType::kw_namespace,
    b"never" => TokenType::kw_never,
    b"new" => TokenType::kw_new,
    b"null" => TokenType::kw_null,
    b"number" => TokenType::kw_number,
    b"object" => TokenType::kw_object,
    b"of" => TokenType::kw_of,
    b"out" => TokenType::kw_out,
    b"override" => TokenType::kw_override,
    b"package" => TokenType::kw_package,
    b"private" => TokenType::kw_private,
    b"protected" => TokenType::kw_protected,
    b"public" => TokenType::kw_public,
    b"readonly" => TokenType::kw_readonly,
    b"require" => TokenType::kw_require,
    b"return" => TokenType::kw_return,
    b"set" => TokenType::kw_set,
    b"static" => TokenType::kw_static,
    b"string" => TokenType::kw_string,
    b"super" => TokenType::kw_super,
    b"switch" => TokenType::kw_switch,
    b"symbol" => TokenType::kw_symbol,
    b"this" => TokenType::kw_this,
    b"throw" => TokenType::kw_throw,
    b"true" => TokenType::kw_true,
    b"try" => TokenType::kw_try,
    b"type" => TokenType::kw_type,
    b"typeof" => TokenType::kw_typeof,
    b"undefined" => TokenType::kw_undefined,
    b"unique" => TokenType::kw_unique,
    b"unknown" => TokenType::kw_unknown,
    b"var" => TokenType::kw_var,
    b"void" => TokenType::kw_void,
    b"while" => TokenType::kw_while,
    b"with" => TokenType::kw_with,
    b"yield" => TokenType::kw_yield,
};

type c_size_t = std::ffi::c_ulong;

#[no_mangle]
pub unsafe extern "C" fn look_up_identifier(
    identifier: *const std::ffi::c_char,
    size: c_size_t,
) -> TokenType {
    let identifier: &[u8] = std::slice::from_raw_parts(identifier.cast::<u8>(), size as usize);
    *KEYWORDS.get(identifier).unwrap_or(&TokenType::identifier)
}
